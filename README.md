# Spring MVC - Udemy course
To the Spring Framework Udemy Course by Neil Alishev

https://www.udemy.com/course/spring-alishev/learn/lecture/31009652

<h2>Lesson 39. "TABLE JOINs. Practice"</h2>

In this lesson we will create tables, build <b>relationships</b> between them and <b>join</b> them.
Let's start. To prepare we will clear our database:

    DROP TABLE Person


<h3>One to Many</h3>

We will practice on a relationship <b>"Director - their Movies"</b>.

<h4>GENERATED BY DEFAULT AS IDENTITY</h4>

causes creating a sequence named <b>sec_<table-name>_<column-name></b> which will
be used to generate and obtain the next unique value from a sequence to be used as
<b>id</b>entifier or <b>IDENTITY</b>.

<h4>PRIMARY KEY <u>PK</u></h4>

The keyword "<b>PRIMARY KEY</b>" denotes that the column will be used as 
<b>identifying key</b> and therefore also must be UNIQUE and NOT NULL.

<u> Let's create a table <b>Director</b></u>:

    CREATE TABLE Director (
        director_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name varchar(100) NOT NULL UNIQUE,
        age  int CHECK ( age >=3 )

    );

<h4>FOREIGN KEY <u>FK</u></h4>
The <b>PostgreSQL</b> keyword "<b>REFERENCES  <Table-name>(<column-name>)</b>" denotes that the column will refer to a column
with the name <b><column-name></b> in some other table named <b><Table-name></b>. 
And that column  is used out there as a <b>PK</b>.

<u> Let's create a table <b>Director</b></u>:

    CREATE TABLE Movie (
        movie_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        director_id int NOT NULL REFERENCES Director(director_id),
        name varchar(200) NOT NULL,
        year_of_production int NOT NULL CHECK (year_of_production > 1888)    
    );


<u>Result will be</u>:

    first_db@localhost
        first_db
            public
                tables
                    director
                        columns
                            director_id
                            name
                            age
                        keys
                            director_pkey
                            director_name_key
                        indexes    
                            director_name_key
                            director_pkey
                        checks
                            director_age_check
                    movie
                        columns
                            movie_id
                            movie.director_id
                            movie.name
                            year_of_production
                        keys
                            movie_pkey
                        foreign_keys    
                            movie_director_id_fkey
                        indexes
                            movie_pkey
                        checks
                            movie_year_of_production_check
                sequences
                    director_director_id_seq    integer
                    movie_movie_id_seq          integer

Now let's fill the table <b>Director</b> with some data:
        
    INSERT INTO Director(name, age) VALUES('Quentin Tarantino', 59);
    INSERT INTO Director(name, age) VALUES('Martin Scorsese', 80);
    INSERT INTO Director(name, age) VALUES('Guy Ritchie', 54);
    INSERT INTO Director(name, age) VALUES('Woody Allen', 87);
    INSERT INTO Director(name, age) VALUES('David Lynch', 76);
    INSERT INTO Director(name, age) VALUES('Cristopher Nolan', 52);

After execute we can check our table:

    SELECT * FROM Director

<u>Result</u> will be:

    1,Quentin Tarantino,59
    2,Martin Scorsese,80
    3,Guy Ritchie,54
    4,Woody Allen,87
    5,David Lynch,76
    6,Cristopher Nolan,52


Now let's add some movies to the table <b>Movie</b>:

    INSERT INTO Movie(director_id, name, year_of_production)
        VALUES(1, 'Reservoir Dogs', 1992);
    INSERT INTO Movie(director_id, name, year_of_production)
        VALUES(1, 'Pulp Fiction', 1994);
    INSERT INTO Movie(director_id, name, year_of_production)
        VALUES(1, 'The Hateful Eight', 2015);
    INSERT INTO Movie(director_id, name, year_of_production)
        VALUES(1, 'Once Upon a Time in Hollywood', 2019);
    INSERT INTO Movie(director_id, name, year_of_production)
        VALUES(2, 'Taxi Driver', 1976);
    INSERT INTO Movie(director_id, name, year_of_production)
        VALUES(2, 'Goodfellas', 1990);
    INSERT INTO Movie(director_id, name, year_of_production)
        VALUES(2, 'The Wolf of Wall Street', 2013);
    INSERT INTO Movie(director_id, name, year_of_production)
        VALUES(3, 'Lock, Stock, and Two Smocking Barrels', 1998);
    INSERT INTO Movie(director_id, name, year_of_production)
        VALUES(3, 'Snatch', 2000);
    INSERT INTO Movie(director_id, name, year_of_production)
        VALUES(4, 'Midight in Paris', 2011);
    INSERT INTO Movie(director_id, name, year_of_production)
        VALUES(6, 'Inception', 2010);

After execute we can check our table:

    SELECT * FROM Movie

<u>Result</u> will be:

    1,1,Reservoir Dogs,1992
    2,1,Pulp Fiction,1994
    3,1,The Hateful Eight,2015
    4,1,Once Upon a Time in Hollywood,2019
    5,2,Taxi Driver,1976
    6,2,Goodfellas,1990
    7,2,The Wolf of Wall Street,2013
    8,3,"Lock, Stock, and Two Smocking Barrels",1998
    9,3,Snatch,2000
    10,4,Midight in Paris,2011
    11,6,Inception,2010


<h4>How also will work REFERENCES</h4>

Keyword <b>REFERENCES</b> defining that the column field is a <b>FOREIGN KEY</b>
referring to some key column in some other table and that column identifies
a row also prohibits possibility to assign to a field marked as <b>REFERENCES</b>
a value which is not listed in the corresponding key column of other table.
e.g. if we try to exectute the next command:

    INSERT INTO MOVIES(director_id, name) 
        VALUES(7, 'Some FIlm')

We get as result the next error message:

    [23503] ERROR: INSERT or UPDATE on table "movie" 
        violates foreign key constraint "movie_director_id_fkey" 
        Details: Key (director_id)=(7) 
        is not present in table "director".

<br>
<h4>[INNER] JOIN</h4>

<u>Command</u>:
     
    SELECT * FROM Director JOIN Movie 
        ON Director.director_id = Movie.director_id

It will cause putting out such as JOINed table:

    1,Quentin Tarantino,59,1,1,Reservoir Dogs
    1,Quentin Tarantino,59,2,1,Pulp Fiction
    1,Quentin Tarantino,59,3,1,The Hateful Eight
    1,Quentin Tarantino,59,4,1,Once Upon a Time in Hollywood
    2,Martin Scorsese,80,5,2,Taxi Driver
    2,Martin Scorsese,80,6,2,Goodfellas
    2,Martin Scorsese,80,7,2,The Wolf of Wall Street
    3,Guy Ritchie,54,8,3,"Lock, Stock, and Two Smocking Barrels"
    3,Guy Ritchie,54,9,3,Snatch
    4,Woody Allen,87,10,4,Midight in Paris
    6,Cristopher Nolan,52,11,6,Inception

Better we would have a join table representing only director's name
and movie they filmed:

    SELECT Movie.name, Director.name FROM Director JOIN Movie
        ON Director.director_id = movie.director_id

And we will have as result the next join table:
    
    Reservoir Dogs,Quentin Tarantino
    Pulp Fiction,Quentin Tarantino
    The Hateful Eight,Quentin Tarantino
    Once Upon a Time in Hollywood,Quentin Tarantino
    Taxi Driver,Martin Scorsese
    Goodfellas,Martin Scorsese
    The Wolf of Wall Street,Martin Scorsese
    "Lock, Stock, and Two Smocking Barrels",Guy Ritchie
    Snatch,Guy Ritchie
    Midight in Paris,Woody Allen
    Inception,Cristopher Nolan

<br>
<h4>LEFT JOIN</h4>

Let's perform executing of <b>LEFT JOIN</b>:

    SELECT Director.name, Movie.name FROM Director LEFT JOIN Movie
        ON Director.director_id = Movie.director_id

And the result will be:

    Quentin Tarantino,Reservoir Dogs
    Quentin Tarantino,Pulp Fiction
    Quentin Tarantino,The Hateful Eight
    Quentin Tarantino,Once Upon a Time in Hollywood
    Martin Scorsese,Taxi Driver
    Martin Scorsese,Goodfellas
    Martin Scorsese,The Wolf of Wall Street
    Guy Ritchie,"Lock, Stock, and Two Smocking Barrels"
    Guy Ritchie,Snatch
    Woody Allen,Midight in Paris
    Cristopher Nolan,Inception
    David Lynch, <null>

So we have got also an extra row with a director, for who there isn't
any entrance in the table <b>'Movie'</b>, and as a value for
column 'Movie.name' there is <null>-value in this LEFT-JOINed table.


<h4>ONE-TO-ONE relationship</h4>

In real life such as relation can be found between <b>Citizens</b>
and their <b>Passports</b>. 

    CREATE TABLE Citizen (
        citizen_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name varchar(100) NOT NULL,
        age int CHECK (age >= 0)
    );

And now we create table <b>'Passport'</b>. But this table will be
a "child" table in relationship with the table <b>'Citizen'</b> - it will
have only <b>Foreign Key</b> as an identifying key:

    CREATE TABLE Passport (
        citizen_id int PRIMARY KEY REFERENCES Citizen,
        passport_number int 
    );
   
Note: we name <b>PRIMARY KEY REFERENCES</b>-column the same as
the parent table <b>KEY</b>-column - here it's <b>citizen_id</b>.
And this KEY-column will be here in the table <b>'Passport'</b> simultaneously as a <b>PRIMARY</b>-KEY and
<b>FOREIGN</b>-KEY.

Let's fill tables with some data:

    INSERT INTO Citizen(name, age) VALUES('Bob', 12);
    INSERT INTO Citizen(name, age) VALUES('Tom', 24);
    INSERT INTO Citizen(name, age) VALUES('Katy', 39);
    INSERT INTO Citizen(name, age) VALUES('Alice', 45);

    INSERT INTO Passport(citizen_id, passport_number) VALUES(1, 12345);
    INSERT INTO Passport(citizen_id, passport_number) VALUES(2, 75124);
    INSERT INTO Passport(citizen_id, passport_number) VALUES(3, 91245);
    INSERT INTO Passport(citizen_id, passport_number) VALUES(4, 19259);

Let's check what we've input:

    SELECT * FROM Citizen;

<u>Result</u>:
    
    1,Bob,12
    2,Tom,24
    3,Katy,39
    4,Alice,45

And 
    
    SELECT * FROM Passport;

<u>Result</u>:

    1,12345
    2,75124
    3,91245
    4,19259


Let's try violate some constraint and to assign to the <b>citizen</b> withi
<b>citizen_id=3</b> one more <b>passport</b>:

    INSERT INTO Passport(citizen_id, passport_number) VALUES (3, 77557);

As a result we'll get the next error message:

    [23505] ERROR: duplicate key value violates
    unique constraint "passport_pkey". 
    Details: Key "(citizen_id)=(3)" already exists.

So now we are sure that there it isn't possible to give away to one person
more than one passport. 
<br>Let's try to violate another constraint: to give away a pass to
a non-existing person:

    INSERT INTO Passport(citizen_id, passport_number) VALUES(5, 55555);

And we will get the error message:

    [23503] ERROR: INSERT or UPDATE on table "passport" 
    violates foreign key constraint "passport_citizen_id_fkey" 
    Details: Key (citizen_id)=(5) does not exist in table "citizen".

This time the constraint <b>REFERENCES</b> has worked. It tracks key
presence in a referred table and prohibits insert a row with a <b>REFERENCES PRIMARY KEY</b>
that does not have corresponding <b>KEY</b> in a parent table.
So we can't have or create a passport for a not listed person.

Let's perform <b>INNER JOIN</b>:

    SELECT Citizen.name, Passport.passport_number 
        FROM Citizen JOIN Passport 
            ON Citizen.citizen_id = Passport.citizen_id;

So we will have join table:

    Bob,12345
    Tom,75124
    Katy,91245
    Alice,19259

Let's try to perform <b>LEFT JOIN</b>:

    SELECT Citizen.name, Passport.passport_number 
        FROM Citizen LEFT JOIN Passport
            ON Citizen.citizen_id = Passport.citizen_id;

And result will be the same because we don't have any citizen 
without a pass and any pass doesn't belong to a person.

So let's add a person who won't have a passport:

    INSERT INTO Citizen(name, age) VALUES('Jane', 0);

And if we perform <b>LEFT JOIN</b> again we will have a row
with the <b><null></b> as <b>Passport.passport_number</b>:

    Bob,12345
    Tom,75124
    Katy,91245
    Alice,19259
    Jane, <null>

<h4>MANY-TO-MANY relationship</h4>

In our examples it can be relationship <b>Actor<->Movie</b>.

Let's create table <b>'Actor'</b> and fill it in with data:

    CREATE TABLE Actor(
        actor_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name varchar(100) NOT NULL,
        age int CHECK(age >= 0)
    );

    
    INSERT INTO Actor(name, age) VALUES('Harvey Keitel', 83);
    INSERT INTO Actor(name, age) VALUES('Robert de Niro', 79);
    INSERT INTO Actor(name, age) VALUES('Leonardo DiCaprio', 48);
    INSERT INTO Actor(name, age) VALUES('Jason Statham', 55);
    INSERT INTO Actor(name, age) VALUES('Joe Pesci', 79);
    INSERT INTO Actor(name, age) VAlUES('Samuel L. Jackson', 74);

So we have:

    SELECT * FROM Actor;

    Harvey Keitel,83
    Robert de Niro,79
    Leonardo DiCaprio,48
    Jason Statham,55
    Joe Pesci,79
    Samuel L. Jackson,74

To implement relationship <b>MANY-TO-MANY</b> we need to
create a linking table - <b>Join table</b> <b>'Actor-Movie'</b>:

    CREATE TABLE Actor_Movie (
        actor_id int REFERENCES Actor(actor_id),
        movie_id int REFERENCES Movie(movie_id),
        PRIMARY KEY (actor_id, movie_id)
    );

This is an example of a <b>multi-component PRIMARY KEY</b>.
And note, we have two column here from which we have this compound
PRIMARY KEY.
The table is created and we can build relations between actors and
movies in which they were filmed:

    INSERT INTO Actor_Movie(actor_id, movie_id)  VALUES (1,1);
    INSERT INTO Actor_Movie(actor_id, movie_id)  VALUES (1,2);
    INSERT INTO Actor_Movie(actor_id, movie_id)  VALUES (2,5);
    INSERT INTO Actor_Movie(actor_id, movie_id)  VALUES (2,6);
    INSERT INTO Actor_Movie(actor_id, movie_id)  VALUES (3,4);
    INSERT INTO Actor_Movie(actor_id, movie_id)  VALUES (3,7);
    INSERT INTO Actor_Movie(actor_id, movie_id)  VALUES (3,11);
    INSERT INTO Actor_Movie(actor_id, movie_id)  VALUES (4,8);
    INSERT INTO Actor_Movie(actor_id, movie_id)  VALUES (4,9);
    INSERT INTO Actor_Movie(actor_id, movie_id)  VALUES (5,6);
    INSERT INTO Actor_Movie(actor_id, movie_id)  VALUES (6,2);
    INSERT INTO Actor_Movie(actor_id, movie_id)  VALUES (6,3);

Let's find out who is the actor and what is the film beside the first row of our join table:

    SELECT * FROM Actor WHERE actor_id=1;
    SELECT * FROM Movie WHERE movie_id=1;

<br>And they is... Harvey Keitel,83 !
<br>And a movie is ... Reservoir Dogs,1992 !
