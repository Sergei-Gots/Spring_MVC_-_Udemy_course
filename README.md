# Spring MVC - Udemy course
To the Spring Framework Udemy Course by Neil Alishev

https://www.udemy.com/course/spring-alishev/learn/lecture/31011706
https://www.udemy.com/course/spring-alishev/learn/lecture/31011890

<h2>Lessons 42. "Prodigy validation: Spring Validator"</h2>

<h3>Before Practice</h3>
be sure you have created appropriately table 'Person':

    CREATE TABLE Person(
        id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name varchar(30) NOT NULL,
        age int CHECK (age >= 0),
        email varchar(32) NOT NULL UNIQUE 
    );

<h3>Reason</h3>
So we have been developing a <b>CRUD-Application for entity 'Person'</b>.
Within the implementation of the entity 'Person' in the class Person we use
validating @annotations for fields.
<br>Also we use @annotation <b>@Valid</b> with the <b>Person person</b>
argument within <b>Controller class PeopleController</b>
and have also argument <b>BindingResult bindingResult</b>
out there to accumulate error messages and verify if there are
any on our forms, our pages or our web-<b>representations</b>.
<br>The such validations we use can operate only on the level
of data getting from user form. So that some errors will remain unchecked
until they meet constraints of database. And such as errors will cause detailed
error reports that are not appropriate to be displayed to the end user of the
application. 
<p>E.g., we have created person with e-mail <b>test@email.com</b>
and try creating a new one with the same email. But
we remember we have <b>UNIQUE</b>-constraint set on field <b>email</b>
on <p>table 'Person'</p>. Because e-mail address is syntax correct
it will be successfully validated, but by trying inserting
this entry in table we will meet DB-constraint, and user
will get the next detailed message in browser:

    HTTP Status 500 â€“ Internal Server Error
    Type Exception Report

    Message Request processing failed; nested exception is org.springframework.dao.DuplicateKeyException: PreparedStatementCallback; SQL [INSERT INTO person(name, age, email) VALUES (?,?,?)]; ERROR: duplicate key value violates unique constraint "person_email_key"

    Description The server encountered an unexpected condition that prevented it from fulfilling the request.

    Exception

    org.springframework.web.util.NestedServletException: Request processing failed; nested exception is org.springframework.dao.DuplicateKeyException: PreparedStatementCallback; SQL [INSERT INTO person(name, age, email) VALUES (?,?,?)]; ERROR: duplicate key value violates unique constraint "person_email_key"
    Detail: Key (email)=(test@mail.com) already exists.; nested exception is org.postgresql.util.PSQLException: ERROR: duplicate key value violates unique constraint "person_email_key"
    Detail: Key (email)=(test@mail.com) already exists.
    org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
    org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)
    javax.servlet.http.HttpServlet.service(HttpServlet.java:681)
    ...

But we want to have a nice short error message:) instead of such a technical
error message show above.
<h3>Approach</h3>
In order to validate values immediately within Database we can use
<div style="color:green"><b>Spring Interface Validator</b> </div>

This interface is used in case of very complex validation, e.g.
with checking information getting from database.

So we will have our implementation for the <b>Interface <u>org.springframework.validation.</u>Validator</b>
For such as auxiliary util classes we <b>create package <u>util</u></b>.
For each entity we create its own validator. 
So that we <b>create</b> there <b>class PersonValidator implements Validator</b>:

    package org.gots.springcourse.util;
    
    import org.gots.springcourse.dao.PersonDAO;
    import org.gots.springcourse.models.Person;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Component;
    import org.springframework.validation.Errors;
    import org.springframework.validation.Validator;
    
    @Component
    public class PersonValidator implements Validator
    {
    
        private final PersonDAO personDAO;
    
        @Autowired
        public PersonValidator(PersonDAO personDAO) {
            this.personDAO = personDAO;
        }
    
        @Override
        public boolean supports(Class<?> clazz) {
            return Person.class.equals(clazz);
        }
    
        public void validate(Object target, Errors errors) {
        //First we should perform downcast:
        Person person = (Person)target;
        String email = person.getEmail();
        Optional<Person> opt = personDAO.show(email); 
        if(opt.isPresent()) {
            //if entry with the entered e-mail already exist in DB
            if(opt.get().getId() != person.getId()) {
                //and if it's not the same entry we try updating
                //we will reject this try
                errors.rejectValue("email", "", "E-mail \"" + email + "\" is already in use.");
            }
        }
    }

Method <b>supports</b> will indicate if the object is appropriate to be validated within this Validator.
method <b>validate</b> will be invoked from <b>Controller</b>-class. Within <b>class Validator</b>
we will use data from database and therefore <b>class PersonDAO</b>.
So we want to check if the e-mail entered in form is not listed already in database.
Let's add appropriate method in <b>class PersonDAO</b>:

    public Optional<Person> show(String email) {
        return jdbcTemplate.query("SELECT * FROM person WHERE email=?",
            new Object[] {email} ,
            new int[] { Types.VARCHAR },
            new BeanPropertyRowMapper<>(Person.class) ).stream().findAny();
    }
    

You see we use her not class <b>Person</b> as a returned type but the class <b>Optional<Person></b>.
It is a contemporary approach for returning value if they can be either a founded Object or null. 
So it's a wrap for objects which can exist or not exist. <b>Optional<T></b> appeared
in <b>Java 8</b>. So let's use <b>Optional<T></b> class in such a cases, it's a good approach.

After all we modify controller <b>class PeopleController</b>:


    @Controller
    @RequestMapping("/people")
    public class PeopleController {
        ...        
        private final PersonValidator personValidator;
    
        @Autowired
        public PeopleController(..., PersonValidator personValidator) {
            ...
            this.personValidator = personValidator;
        }
    
        @PostMapping()
        public String create(@ModelAttribute("person") @Valid Person person,
                             BindingResult bindingResult) {
    
            personValidator.validate(person, bindingResult);
        
            if(bindingResult.hasErrors()) {
                return "/people/new";
            }
        
            personDAO.save(person);
            return "redirect:/people";
        }
    
        
        /** Request to update that has been edited  **/
        @PatchMapping("/{id}")
        public String update(@ModelAttribute("person") @Valid Person person, BindingResult bindingResult,
                             @PathVariable("id") int id) {
    
            personValidator.validate(person, bindingResult);
            if(bindingResult.hasErrors()) {
                return "/people/edit";
            }
            personDAO.update(id, person);
            return  "redirect:/people";
        }
        ...
    }



We added here field <b>private final PersonValidator personValidator</b> and added its initialisation
with <b>@Autowired</b> in constructor. And we added invocation of <b>personValidator.validate(person, bindingResult)</b>.
in the methods <b>create</b> and <b>update</b>:

            personValidator.validate(person, bindingResult);

So that <b>BindingResult bindingResult</b> in these methods will accumulate all errors from all the
validation levels.
<br>And now if we try to input already existing in some other entry e-mail we will get a smart error message
immediately in the form:

    Enter name: Sergei
    Enter age:  10
    Enter e-mail: test@mail.com
<div style ="color:red">E-mail "test@mail.com" is already in use. </div>
<br>:)



